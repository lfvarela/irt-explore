# File to generate Student matrices and Concepts matrices
import numpy as np


def generate_student_matrix(skill_dist, n=100, c=10, correl=False):
    """
    :param skill_dist: Probability Distribution function that generates real numbers
    between [0, 1]. Distribution must depend on one variable theta between [0, 1], sampled from theta_dist
    :param n: Number of students
    :param c: Number of skills
    :param correl: Boolean that specifies if sampling will be correlated

    :return: s, a generated matrix of size N x C. S_ij represents the skill of
    student i in concept j. A skill is a real number between 0 and 1, sampled
    from {skill_dist}.
    """
    s = np.zeros((n, c))
    for i in range(n):
        for j in range(c):
            s[i, j] = skill_dist(correl)
    return s


def generate_questions_matrix(difficulty_dist, q=100, c=10):
    """
    :param difficulty_dist: function to generate the difficulty level of a question
    :param q: number of questions
    :param c: number of skills
    :return: n x c matrix
    """
    questions = np.zeros((q, c))
    for i in range(q):
        skill = np.random.randint(c)
        questions[i, skill] = difficulty_dist()

    return questions


def normal_0_1(correl=False):
    """
    :param correl: Boolean that specifies if sampling will be correlated

    :return: returns a number between 0 and 1 sampled from a normal distribution with mean=0.5 or theta if correl is
    True and std=0.25
    """
    if not correl:
        while True:
            difficulty = np.random.normal(0.5, 0.25, 1)
            if 0 <= difficulty <= 1:
                return difficulty
    else:
        theta = np.random.normal(0.5, 0.25, 1)
        while True:
            difficulty = np.random.normal(theta, 0.25, 1)
            if 0 <= difficulty <= 1:
                return difficulty


def generate_matrices(n=50, q=100, c=10, correl=False):
    """
    :return: 
        At 0: student matrix of n rows and c columns, where 0 < m_ij < 1 represents the skill of student i in concept j. m_ij is currently being generated by normal_0_1 function independently. This method is still under consideration.
        At 1: questions matrix of q rows and c columns, where 0 < m_ij < 1 represents the difficulty of question i in concept j. 
    """

    student_matrix = generate_student_matrix(normal_0_1, n, c, correl)
    questions_matrix = generate_questions_matrix(normal_0_1, q, c)
    return student_matrix, questions_matrix


def generate_responses(student_matrix, questions_matrix, guess_prob, irf, *args):
    """
    Generate simulated data for student responses to questions.
    :param student_matrix: N x C matrix. s_ij is student i's ability in concept j
    :param questions_matrix: Q x C matrix. q_ij is the difficulty of question i in concept j. Note that only one element in row i can be nonzero.
    :param guess_prob: probability
    :param irf: item response function used to generate responses
    :param args: extra arguments needed for irf, if any
    :return: Generate simulated data: N x Q matrix where m_ij = 0 iff student i responded question j correctly.
    """
    responses = np.zeros((student_matrix.shape[0], questions_matrix.shape[0]))
    for i, student in enumerate(student_matrix):
        for j, question in enumerate(questions_matrix):
            concept = np.nonzero(question)[0]
            prob = irf(student[concept], guess_prob, question[concept], *args)
            if np.random.uniform() <= prob:
                responses[i, j] = 1
    return responses


if __name__ == '__main__':
    student_matrix, questions_matrix = generate_matrices(10, 5, 2)
    print('Student Matrix: ')
    print(student_matrix)

    print('Questions Matrix: ')
    print(questions_matrix)
